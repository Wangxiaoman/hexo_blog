title: java程序员需要了解的计算机工作原理
date: 2015-11-12 18:00:49
tags: [技术]
category: 技术
---

## 1、cpu
进程或者线程发出操作请求之后，cpu会分配时间片来处理。处理的时候将参数传递给cpu，cpu计算完将本地变量回写到栈（内存中）中，如果这种本地变量多次的操作，那么会cache到cpu的缓存中，cpu有寄存器、一级缓存、二级缓存、三级缓存。

<!--more-->

JVM只能发出操作指令，由OS完成具体的计算工作。

### cache line
一次拿一批的数据来处理（连续的一段内存区域，从内存中，修改的话也有响应的规则回写）。

### 缓存一致性
多个cpu如果加载了同一块内存数据，那么这部分数据将处于共享状态（Intel QPI技术）。

### 并发与征用
线程池中，如果在cpu密集型的情况下，如果线程非常多，cpu会频繁的切换上下文，负载增加，反倒会降低效率；
如果是IO密集型的系统中，本身就需要大量的线程，不在乎上下文切换的开销；

CPU密集型：系统大部分时间都在做计算任务。比如数学计算、循环、拷贝、查找、排序。
IO密集型：系统大部分时间都在等待IO的交互。

常规操作，CPU密集型，一般来说建议线程并发处理的数量是 CPU核数 +/- 1，这样可以基本实现无上下文切换。
IO操作（网络IO，磁盘IO，DB读写，缓存读写等等），一般来说会设定 线程数 = CPU核数*6。
锁，这种情况下是比较负载，需要根据锁的粒度进行分析（估算），比如ConcurrentHashMap中进行了分段，有16个Segment，那么是允许16个线程来并行的，但是也会出现热点问题（某一个Segment访问数量远远大于其他）。

## 2、内存
### 内存地址的一些概念
- 物理地址，地址总线上的对应关系，每个地址为0|1表达不同的地址，物理地址是唯一的，通过内存电路来控制。（每个程序都会分配一个起始地址+逻辑地址，得到线性地址，这其实就是物理地址）
- 虚拟地址，所有“程序”使用的都是虚拟地址。（为什么是使用虚拟地址呢？以C为例，编译后的指令中，许多调用的地址在编译阶段就已经确定，所以方法入口和变量位置在编译的时候确定了虚拟地址，在运行的时候再由OS对应到物理地址）。
- 分页模型，将内存区域划分成较小的页，物理上大部分为4KB，页目录->页表->物理地址

## 3、磁盘
### 机械磁盘
- 有一个摆头（磁头），在盘片上寻道（一块盘有多磁道），盘身转动到起始位置，然后开始读取数据。
- 数据读取的快慢一般和尺寸还有转速相关（一般在ms级别）。
- RAID（阵列），实现硬盘上的负载均衡（会冗余数据到不同块的硬盘上）。

### SSD
- IOPS是传统硬盘的几百倍

## 4、缓存
- 目的是提高性能和效率
- 方法是“就近原则”
- 一般用在读多写少的场景下
- 一般是在非强一致性的场景下

## 5、网络与DB
浏览器访问服务的一个过程中，浏览器访问到Web服务器是网络IO；Web服务器访问DB服务器，也是网络IO；DB访问硬盘数据是磁盘IO。IO无处不在。

### 网络
- IO传输数据都是基于字节（目的是统一）的
- 字符数据的传输需要编解码
- java所有的IO都会经历一个Socket或者Channel的过程，这些数据一般会经过JVM，到OS管理的一块内核态区域，再由Kernel去完成输出的交互

### java与数据库交互
- 大部分java与数据库的通信都是基于java的Socket，并且都是BIO的模型（从实际需求出发，AIO貌似也没有意义）。
- JDBC是基于Socket上的一种协议，由不同的DB厂商来实现统一的JDBC接口








